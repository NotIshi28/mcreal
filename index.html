<html><head>
  <title>Enhanced Infinite Minecraft-like World</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
<style>
  body { margin: 0; overflow: hidden; }
  #info {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    color: white;
    font-family: Arial, sans-serif;
    pointer-events: none;
    text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
  }
  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255,255,255,0.7);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }
</style>
</head>
<body>
<div id="info">Enhanced Infinite Minecraft-like World<br>WASD to move, Space/Shift to go up/down</div>
<div id="crosshair"></div>
<script>
let scene, camera, renderer, controls;
let raycaster;
let world = {};
let chunkSize = 16;
let chunkHeight = 256;
let blockSize = 1;
let textureLoader, blockTextures;
let generatedChunks = new Set();
let chunks = {};
let renderDistance = 6; // Increased render distance

const simplex = new SimplexNoise();

const atlasSize = 256;
const tileSize = 16;
const tilesPerRow = atlasSize / tileSize;

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 50, renderDistance * chunkSize * 0.8); // Add fog

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(5, 50, 5);

  renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable antialiasing
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true; // Enable shadow mapping
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use soft shadows
  document.body.appendChild(renderer.domElement);

  textureLoader = new THREE.TextureLoader();
  blockTextures = textureLoader.load('https://minecraft.wiki/images/Rd-161348_terrain.png', function(texture) {
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.LinearMipMapLinearFilter; // Use mipmapping for better texture quality at distance
    generateInitialChunks();
  });

  raycaster = new THREE.Raycaster();

  setupLights();
  setupControls();
  setupSky();

  window.addEventListener('resize', onWindowResize, false);
  document.addEventListener('mousedown', onDocumentMouseDown, false);
  document.addEventListener('keydown', onKeyDown, false);
  document.addEventListener('keyup', onKeyUp, false);
}

function setupLights() {
  const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(100, 100, 50);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 1;
  directionalLight.shadow.camera.far = 500;
  directionalLight.shadow.camera.left = -200;
  directionalLight.shadow.camera.right = 200;
  directionalLight.shadow.camera.top = 200;
  directionalLight.shadow.camera.bottom = -200;
  scene.add(directionalLight);
}

function setupSky() {
  const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
  const skyMaterial = new THREE.ShaderMaterial({
    uniforms: {
      topColor: { value: new THREE.Color(0x0077ff) },
      bottomColor: { value: new THREE.Color(0xffffff) },
      offset: { value: 33 },
      exponent: { value: 0.6 }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      varying vec3 vWorldPosition;
      void main() {
        float h = normalize(vWorldPosition + offset).y;
        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
      }
    `,
    side: THREE.BackSide
  });
  const sky = new THREE.Mesh(skyGeometry, skyMaterial);
  scene.add(sky);
}

function setupControls() {
  controls = new THREE.PointerLockControls(camera, document.body);
  
  document.addEventListener('click', () => {
    controls.lock();
  });

  scene.add(controls.getObject());
}

function generateInitialChunks() {
  const playerChunkX = Math.floor(camera.position.x / (chunkSize * blockSize));
  const playerChunkZ = Math.floor(camera.position.z / (chunkSize * blockSize));

  for (let x = -renderDistance; x <= renderDistance; x++) {
    for (let z = -renderDistance; z <= renderDistance; z++) {
      generateChunk(playerChunkX + x, playerChunkZ + z);
    }
  }
}

function generateChunk(chunkX, chunkZ) {
  const chunkKey = `${chunkX},${chunkZ}`;
  if (generatedChunks.has(chunkKey)) return;

  let positions = [];
  let normals = [];
  let uvs = [];

  for (let x = 0; x < chunkSize; x++) {
    for (let z = 0; z < chunkSize; z++) {
      let worldX = chunkX * chunkSize + x;
      let worldZ = chunkZ * chunkSize + z;
      let height = Math.floor(getNoiseHeight(worldX, worldZ));
      
      for (let y = 0; y <= height && y < chunkHeight; y++) {
        let type = y === height ? 'grass' : (y > height - 4 ? 'dirt' : 'stone');
        if (!world[`${worldX},${y},${worldZ}`]) {
          world[`${worldX},${y},${worldZ}`] = type;
        }
      }
    }
  }

  updateChunkGeometry(chunkX, chunkZ, positions, normals, uvs);

  const chunkGeometry = new THREE.BufferGeometry();
  chunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  chunkGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
  chunkGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

  const chunkMaterial = new THREE.MeshLambertMaterial({ 
    map: blockTextures,
    vertexColors: false,
    shadowSide: THREE.FrontSide
  });

  const chunkMesh = new THREE.Mesh(chunkGeometry, chunkMaterial);
  chunkMesh.position.set(chunkX * chunkSize * blockSize, 0, chunkZ * chunkSize * blockSize);
  chunkMesh.castShadow = true;
  chunkMesh.receiveShadow = true;
  scene.add(chunkMesh);

  chunks[chunkKey] = chunkMesh;
  generatedChunks.add(chunkKey);
}

function getNoiseHeight(x, z) {
  const scale = 0.005;
  const octaves = 6;
  const persistence = 0.5;
  const lacunarity = 2.0;
  const exponentiation = 4;

  let amplitude = 1.0;
  let frequency = 1.0;
  let noiseHeight = 0;

  for (let i = 0; i < octaves; i++) {
    const sampleX = x * scale * frequency;
    const sampleZ = z * scale * frequency;
    
    const perlinValue = simplex.noise2D(sampleX, sampleZ);
    noiseHeight += perlinValue * amplitude;

    amplitude *= persistence;
    frequency *= lacunarity;
  }

  noiseHeight = (noiseHeight + 1) * 0.5;
  noiseHeight = Math.pow(noiseHeight, exponentiation);

  return Math.floor(noiseHeight * (chunkHeight - 1));
}

function updateChunkGeometry(chunkX, chunkZ, positions, normals, uvs) {
  for (let x = 0; x < chunkSize; x++) {
    for (let z = 0; z < chunkSize; z++) {
      for (let y = 0; y < chunkHeight; y++) {
        let worldX = chunkX * chunkSize + x;
        let worldY = y;
        let worldZ = chunkZ * chunkSize + z;
        let blockType = world[`${worldX},${worldY},${worldZ}`];
        if (blockType) {
          addBlockToChunk(x, y, z, blockType, worldX, worldY, worldZ, positions, normals, uvs);
        }
      }
    }
  }
}

function addBlockToChunk(x, y, z, type, worldX, worldY, worldZ, positions, normals, uvs) {
  const topUVs = type === 'grass' ? getUVs(0, 0) : (type === 'dirt' ? getUVs(2, 0) : getUVs(1, 0));
  const sideUVs = type === 'grass' ? getUVs(3, 0) : (type === 'dirt' ? getUVs(2, 0) : getUVs(1, 0));
  const bottomUVs = type === 'grass' ? getUVs(2, 0) : (type === 'dirt' ? getUVs(2, 0) : getUVs(1, 0));

  if (!world[`${worldX},${worldY+1},${worldZ}`]) {
    addFace(x, y+1, z, x, y+1, z+1, x+1, y+1, z+1, x+1, y+1, z, 0, 1, 0, topUVs, positions, normals, uvs);
  }
  if (!world[`${worldX},${worldY-1},${worldZ}`]) {
    addFace(x, y, z+1, x, y, z, x+1, y, z, x+1, y, z+1, 0, -1, 0, bottomUVs, positions, normals, uvs);
  }
  if (!world[`${worldX},${worldY},${worldZ+1}`]) {
    addFace(x+1, y+1, z+1, x, y+1, z+1, x, y, z+1, x+1, y, z+1, 0, 0, 1, sideUVs, positions, normals, uvs);
  }
  if (!world[`${worldX},${worldY},${worldZ-1}`]) {
    addFace(x, y+1, z, x+1, y+1, z, x+1, y, z, x, y, z, 0, 0, -1, sideUVs, positions, normals, uvs);
  }
  if (!world[`${worldX+1},${worldY},${worldZ}`]) {
    addFace(x+1, y+1, z, x+1, y+1, z+1, x+1, y, z+1, x+1, y, z, 1, 0, 0, sideUVs, positions, normals, uvs);
  }
  if (!world[`${worldX-1},${worldY},${worldZ}`]) {
    addFace(x, y+1, z+1, x, y+1, z, x, y, z, x, y, z+1, -1, 0, 0, sideUVs, positions, normals, uvs);
  }
}

function addFace(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, nx, ny, nz, uv, positions, normals, uvs) {
  positions.push(
    x1, y1, z1, x2, y2, z2, x3, y3, z3,
    x1, y1, z1, x3, y3, z3, x4, y4, z4
  );
  for (let i = 0; i < 6; i++) {
    normals.push(nx, ny, nz);
  }
  uvs.push(
    uv[0].x, uv[0].y, uv[1].x, uv[1].y, uv[2].x, uv[2].y,
    uv[0].x, uv[0].y, uv[2].x, uv[2].y, uv[3].x, uv[3].y
  );
}

function getUVs(tileX, tileY) {
  const u = tileX / tilesPerRow;
  const v = 1 - (tileY + 1) / tilesPerRow;
  const tileUVSize = 1 / tilesPerRow;
  return [
    new THREE.Vector2(u, v + tileUVSize),
    new THREE.Vector2(u + tileUVSize, v + tileUVSize),
    new THREE.Vector2(u + tileUVSize, v),
    new THREE.Vector2(u, v)
  ];
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onDocumentMouseDown(event) {
  if (!controls.isLocked) return;

  raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

  const intersects = raycaster.intersect
Objects(Object.values(chunks));

  if (intersects.length > 0) {
    const intersect = intersects[0];
    const voxelPosition = new THREE.Vector3()
      .addVectors(intersect.point, intersect.face.normal.multiplyScalar(event.button === 0 ? 0.5 : -0.5))
      .floor();

    const worldX = Math.floor(voxelPosition.x);
    const worldY = Math.floor(voxelPosition.y);
    const worldZ = Math.floor(voxelPosition.z);

    if (event.button === 0) {
      placeBlock(worldX, worldY, worldZ, 'grass');
    } else if (event.button === 2) {
      removeBlock(worldX, worldY, worldZ);
    }
  }
}

function placeBlock(x, y, z, type) {
  const key = `${x},${y},${z}`;
  if (world[key]) return;

  world[key] = type;
  updateChunksAroundBlock(x, y, z);
}

</script>
</body>
</html>